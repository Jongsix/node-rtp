// Generated by CoffeeScript 1.6.2
var Buffer, MARKER_BIT, RTP_HEADER_SIZE, RtpPacket, TYPE_MASK, isSet;

Buffer = require('buffer').Buffer;

Number.prototype.toUnsigned = function() {
  return (this >>> 1) * 2 + (this & 1);
};

RTP_HEADER_SIZE = 12;

MARKER_BIT = 0x80;

TYPE_MASK = 0x7F;

isSet = function(where, mask) {
  return mask === (where & mask);
};

RtpPacket = (function() {
  function RtpPacket(bufPayload, fullPacket) {
    var SN;

    if (bufPayload instanceof RtpPacket) {
      this._bufpkt = new Buffer(bufPayload.packet.length);
      bufPayload.packet.copy(this._bufpkt);
      return;
    }
    if (!Buffer.isBuffer(bufPayload)) {
      throw new Error('not a buffer');
    }
    /*
    See RFC3550 for more details: http://www.ietf.org/rfc/rfc3550.txt
    V = 2, // version. always 2 for this RFC (2 bits)
    P = 0, // padding. not supported yet, so always 0 (1 bit)
    X = 0, // header extension (1 bit)
    CC = 0, // CSRC count (4 bits)
    M = 0, // marker (1 bit)
    PT = 0, // payload type. see section 6 in RFC3551 for valid types: http://www.ietf.org/rfc/rfc3551.txt (7 bits)
    SN = Math.floor(1000 * Math.random()), // sequence number. SHOULD be random (16 bits)
    TS = 1, // timestamp in the format of NTP (# sec. since 0h UTC 1 January 1900)? (32 bits)
    SSRC = 1; // synchronization source (32 bits)
    //CSRC = 0, // contributing sources. not supported yet (32 bits)
    //DP = 0, // header extension, 'Defined By Profile'. not supported yet (16 bits)
    //EL = 0; // header extension length. not supported yet (16 bits)
    */

    if (fullPacket === undefined || fullPacket === null) {
      fullPacket = false;
    }
    if (fullPacket) {
      this._bufpkt = bufPayload;
    } else {
      this._bufpkt = new Buffer(RTP_HEADER_SIZE + bufPayload.length);
      this._bufpkt[0] = 0x80;
      this._bufpkt[1] = 0;
      SN = Math.floor(1000 * Math.random());
      this._bufpkt[2] = SN >>> 8;
      this._bufpkt[3] = SN & 0xFF;
      this._bufpkt[4] = 0;
      this._bufpkt[5] = 0;
      this._bufpkt[6] = 0;
      this._bufpkt[7] = 1;
      this._bufpkt[8] = 0;
      this._bufpkt[9] = 0;
      this._bufpkt[10] = 0;
      this._bufpkt[11] = 1;
      bufPayload.copy(this._bufpkt, 12, 0);
    }
  }

  return RtpPacket;

})();

RtpPacket.prototype.__defineGetter__('marker', function() {
  return isSet(this._bufpkt[1], MARKER_BIT);
});

RtpPacket.prototype.__defineSetter__('marker', function(set) {
  if (set) {
    return this._bufpkt[1] |= MARKER_BIT;
  } else {
    return this._bufpkt[1] &= ~MARKER_BIT;
  }
});

RtpPacket.prototype.__defineGetter__('type', function() {
  return this._bufpkt[1] & TYPE_MASK;
});

RtpPacket.prototype.__defineSetter__('type', function(val) {
  val = val.toUnsigned();
  if (val <= 127) {
    this._bufpkt[1] -= this._bufpkt[1] & TYPE_MASK;
    return this._bufpkt[1] |= val;
  }
});

RtpPacket.prototype.__defineGetter__('seq', function() {
  return this._bufpkt[2] << 8 | this._bufpkt[3];
});

RtpPacket.prototype.__defineSetter__('seq', function(val) {
  val = val.toUnsigned();
  if (val <= 65535) {
    this._bufpkt[2] = val >>> 8;
    return this._bufpkt[3] = val & 0xFF;
  }
});

RtpPacket.prototype.__defineGetter__('time', function() {
  return this._bufpkt[4] << 24 | this._bufpkt[5] << 16 | this._bufpkt[6] << 8 | this._bufpkt[7];
});

RtpPacket.prototype.__defineSetter__('time', function(val) {
  val = val.toUnsigned();
  if (val <= 4294967295) {
    this._bufpkt[4] = val >>> 24;
    this._bufpkt[5] = val >>> 16 & 0xFF;
    this._bufpkt[6] = val >>> 8 & 0xFF;
    return this._bufpkt[7] = val & 0xFF;
  }
});

RtpPacket.prototype.__defineGetter__('source', function() {
  return this._bufpkt[8] << 24 | this._bufpkt[9] << 16 | this._bufpkt[10] << 8 | this._bufpkt[11];
});

RtpPacket.prototype.__defineSetter__('source', function(val) {
  val = val.toUnsigned();
  if (val <= 4294967295) {
    this._bufpkt[8] = val >>> 24;
    this._bufpkt[9] = val >>> 16 & 0xFF;
    this._bufpkt[10] = val >>> 8 & 0xFF;
    return this._bufpkt[11] = val & 0xFF;
  }
});

RtpPacket.prototype.__defineGetter__('payload', function() {
  return this._bufpkt.slice(RTP_HEADER_SIZE, this._bufpkt.length);
});

RtpPacket.prototype.__defineSetter__('payload', function(val) {
  var newbuf, newsize;

  if (Buffer.isBuffer(val && val.length <= 512)) {
    newsize = RTP_HEADER_SIZE + val.length;
    if (newsize === this._bufpkt.length) {
      return val.copy(this._bufpkt, RTP_HEADER_SIZE, 0);
    } else {
      newbuf = new Buffer(newsize);
      this._bufpkt.copy(newbuf, 0, 0, RTP_HEADER_SIZE);
      val.copy(newbuf, RTP_HEADER_SIZE, 0);
      return this._bufpkt = newbuf;
    }
  }
});

RtpPacket.prototype.__defineGetter__('packet', function() {
  return this._bufpkt;
});

exports.RtpPacket = RtpPacket;
